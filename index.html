<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Holographic Display System — Integrated Demo</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://cdnjs.cloudflare.com/ajax/libs" />
  <style>
    :root {
      --cyan: #40e0ff;
      --green: #00ff88;
      --ink: #0a0a0a;
      --ink2: #1a1a2e;
      --ink3: #16213e;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: #fff;
      background: linear-gradient(135deg, var(--ink) 0%, var(--ink2) 50%, var(--ink3) 100%);
      overflow: hidden;
    }
    /* ======= Top Nav / Landing ======= */
    .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
    header { display: flex; align-items: center; justify-content: space-between; padding: 1rem 0; }
    .logo { font-weight: 800; font-size: 1.4rem; letter-spacing: 0.4px; color: var(--cyan); display: flex; gap: 8px; align-items: center; }
    .logo .dot { font-size: 1.6rem; }
    .hero { text-align: center; padding: 3rem 0 2rem; }
    .hero h1 {
      font-size: clamp(2rem, 3vw + 1rem, 3.2rem);
      line-height: 1.1;
      background: linear-gradient(90deg, #00dbde, #fc00ff);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      margin-bottom: 1rem;
    }
    .subtitle { opacity: .9; max-width: 760px; margin: 0 auto; line-height: 1.6; font-size: 1.05rem; }
    .cta { margin-top: 1.5rem; }
    .btn {
      appearance: none; border: 0; cursor: pointer; user-select: none;
      background: linear-gradient(90deg, #00dbde, #fc00ff);
      color: #fff; padding: .9rem 1.4rem; border-radius: 999px; font-weight: 700;
      transition: transform .2s ease, box-shadow .2s ease; font-size: 1rem;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(0,0,0,.35); }
    .features { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 1.25rem; margin-top: 2.5rem; }
    @media (max-width: 900px) { .features { grid-template-columns: 1fr; } }
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      padding: 1.5rem; border-radius: 18px; text-align: center; transition: transform .25s ease, box-shadow .25s ease;
    }
    .card:hover { transform: translateY(-6px); box-shadow: 0 16px 32px rgba(0,0,0,.2); border-color: rgba(64,224,255,.4); }
    .card .emoji { font-size: 2rem; display: block; margin-bottom: .5rem; }
    /* ======= Explorer Grid ======= */
    #explorer { display: none; position: absolute; inset: 0; overflow-y: auto; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
    .grid-item {
      position: relative; height: 320px; padding: 1.2rem; border-radius: 18px;
      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
      display: flex; flex-direction: column; justify-content: space-between; align-items: center; text-align: center;
      overflow: hidden; transition: transform .25s ease, box-shadow .25s ease, border-color .25s ease;
      cursor: pointer;
    }
    .grid-item:hover { transform: translateY(-6px); box-shadow: 0 16px 32px rgba(0,0,0,.2); border-color: rgba(64,224,255,.4); }
    .grid-item h3 { background: linear-gradient(90deg, #00dbde, #fc00ff); -webkit-background-clip: text; background-clip: text; color: transparent; }
    /* Simple CSS mini-previews */
    .mini { width: 180px; height: 180px; margin: 0 auto; position: relative; }
    .sun { position:absolute; inset:auto; width:40px;height:40px;border-radius:50%; background: radial-gradient(circle, #ffd700, #ff8c00); top:50%; left:50%; transform: translate(-50%, -50%); box-shadow: 0 0 24px #ff8c00, 0 0 48px #ff4500; }
    .orbit { position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); border-radius: 50%; border: 1px solid rgba(255,255,255,.25); }
    .planet { position:absolute; width:12px; height:12px; border-radius:50%; background:#4bc7cf; top:0; left:50%; transform: translate(-50%,-50%); animation: spin 6s linear infinite; }
    @keyframes spin { to { transform: translate(-50%,-50%) rotate(360deg); } }
    .dna-backbone { position:absolute; top:0; bottom:0; width:4px; border-radius: 4px; background: linear-gradient(to bottom, transparent, #00dbde, transparent); }
    .dna-backbone.left { left: 40%; }
    .dna-backbone.right { right: 40%; }
    .dna-base { position:absolute; left: 40%; width: 28px; height: 4px; border-radius: 2px; background: linear-gradient(90deg, #fc00ff, #00dbde); transform-origin: left center; }
    .heart { position:relative; width: 98px; height: 86px; animation: thump 1.2s infinite; }
    .heart:before, .heart:after { content:""; position:absolute; width:50px;height:78px; background: linear-gradient(#ff6b6b, #ff3838); border-radius: 50px 50px 0 0; box-shadow: 0 0 18px rgba(255,107,107,.6); }
    .heart:before { left:50px; transform: rotate(-45deg); transform-origin: 0 100%; }
    .heart:after { left:0; transform: rotate(45deg); transform-origin: 100% 100%; }
    @keyframes thump { 0%,50%,100%{ transform: scale(1);} 25%{ transform: scale(1.07);} }
    .nucleus { position:absolute; width:26px;height:26px; border-radius:50%; background: radial-gradient(circle,#00dbde,#0077ff); top:50%; left:50%; transform: translate(-50%,-50%); box-shadow:0 0 12px #00dbde; }
    .e-orbit { position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); border-radius:50%; border: 1px solid rgba(0,219,222,.35); }
    .e { position:absolute; top:0; left:50%; transform: translate(-50%,-50%); width:8px;height:8px;border-radius:50%; background:#00dbde; box-shadow:0 0 8px #00dbde; animation: spin 3s linear infinite; }
    /* ======= Player (Three.js + Gestures) ======= */
    #player { position: absolute; inset: 0; display: none; }
    #container3d { position: absolute; inset: 0; display: flex; }
    #viewport { position: relative; background: radial-gradient(ellipse at center, #101828 0%, #05070c 100%); flex: 1; }
    #panel { 
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 320px;
      background: rgba(0,20,40,.95); 
      backdrop-filter: blur(10px); 
      border-left: 1px solid rgba(64,224,255,.3); 
      padding: 18px; 
      overflow-y: auto;
      transition: all 0.3s ease;
      transform: translateX(100%);
      opacity: 0;
      visibility: hidden;
      z-index: 100;
    }
    #panel.active {
      transform: translateX(0);
      opacity: 1;
      visibility: visible;
    }
    #video { position: absolute; top: 16px; right: 16px; width: 220px; height: 165px; border: 2px solid var(--cyan); border-radius: 10px; transform: scaleX(-1); z-index: 5; background:#000; }
    .info { position: absolute; top: 16px; left: 16px; background: rgba(0,20,40,.8); border:1px solid rgba(64,224,255,.3); padding: 12px 14px; border-radius: 10px; backdrop-filter: blur(10px); z-index: 5; font-size: 12px; }
    .info h3 { color: var(--cyan); margin-bottom: 6px; font-size: 13px; }
    .status { color: var(--cyan); margin: 2px 0; }
    .gesture-badge { position: absolute; left: 16px; bottom: 16px; background: rgba(0,20,40,.85); border:1px solid rgba(64,224,255,.3); padding: 10px 12px; border-radius: 8px; z-index: 5; font-size: 12px; }
    .holo-overlay { position:absolute; inset:0; pointer-events:none; background:
      radial-gradient(circle at 30% 30%, rgba(64,224,255,.09) 0%, transparent 50%),
      radial-gradient(circle at 70% 70%, rgba(0,255,128,.08) 0%, transparent 50%);
      animation: shimmer 3s ease-in-out infinite alternate;
    }
    @keyframes shimmer { 0%{opacity:.32} 100%{opacity:.7} }
    .group { margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,.05); border-radius: 10px; border: 1px solid rgba(64,224,255,.2); }
    .group h4 { color: var(--cyan); margin-bottom: 8px; font-size: 13px; }
    .pill { display:inline-block; background: linear-gradient(45deg, var(--cyan), #0080ff); color:#fff; border:0; padding:8px 12px; border-radius: 999px; font-size: 12px; cursor:pointer; margin: 4px 4px 0 0; }
    .pill.alt { background: linear-gradient(45deg, var(--green), #00cc66); }
    input[type="range"].slider { width: 100%; height: 8px; background: rgba(255,255,255,.12); border-radius: 6px; }
    .loading { position: fixed; inset: 0; display: grid; place-items:center; background: rgba(3,6,12,.6); z-index: 999; }
    .spinner { width: 56px;height:56px; border-radius:50%; border:4px solid rgba(64,224,255,.35); border-top-color: var(--cyan); animation: spin2 1s linear infinite; }
    @keyframes spin2 { to { transform: rotate(360deg); } }
    .back { position: absolute; top: 14px; right: 346px; z-index: 6; }
    /* Navigation Dot */
    .nav-dot {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--cyan), var(--green));
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 200;
      box-shadow: 0 0 20px rgba(64, 224, 255, 0.5);
      transition: all 0.3s ease;
    }
    
    .nav-dot:hover {
      transform: scale(1.1);
      box-shadow: 0 0 25px rgba(64, 224, 255, 0.7);
    }
    
    .nav-dot::before {
      content: "☰";
      font-size: 24px;
      color: white;
    }
    
    .nav-dot.active::before {
      content: "✕";
    }
    /* Ensure panel content is readable */
    #panel label {
      color: #cbd5e1;
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <!-- Landing -->
  <section id="landing">
    <div class="container">
      <header>
        <div class="logo"><span class="dot">⊚</span>Holographic Systems</div>
      </header>
      <div class="hero">
        <h1>Holographic Display System with Gesture Recognition</h1>
        <p class="subtitle">Experience natural 3D interaction. Pick a model, wave your hand (or drag with the mouse), and watch the hologram respond in real-time.</p>
        <div class="cta"><button id="goExplorer" class="btn">Explore Technology</button></div>
      </div>
      <div class="features">
        <div class="card"><span class="emoji">👋</span><h3>Gesture Control</h3><p>Open palm to rotate · Pinch to scale · Point to move · Peace to reset</p></div>
        <div class="card"><span class="emoji">🧊</span><h3>Glassy UI</h3><p>Glowing, glassmorphism panels with real-time status</p></div>
        <div class="card"><span class="emoji">⚡</span><h3>Low-latency</h3><p>Mediapipe Hands + Three.js rendering loop</p></div>
      </div>
    </div>
  </section>
  <!-- Explorer -->
  <section id="explorer">
    <div class="container">
      <header>
        <div class="logo"><span class="dot">⊚</span>Holographic Systems</div>
        <button id="backToLanding" class="btn" style="background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);">Back</button>
      </header>
      <h2 class="hero" style="padding-top:1rem;">Pick a Hologram</h2>
      <div class="grid">
        <div class="grid-item" data-scene="solar">
          <h3>Solar System</h3>
          <div class="mini">
            <div class="sun"></div>
            <div class="orbit" style="width:120px;height:120px;"><div class="planet"></div></div>
            <div class="orbit" style="width:160px;height:160px;"><div class="planet" style="animation-duration:8s; background:#ff6b6b;"></div></div>
            <div class="orbit" style="width:200px;height:200px;"><div class="planet" style="animation-duration:12s; background:#7bed9f;"></div></div>
          </div>
          <p>Planets orbiting a glowing sun</p>
        </div>
        <div class="grid-item" data-scene="dna">
          <h3>DNA Molecule</h3>
          <div class="mini" id="miniDNA">
            <div class="dna-backbone left"></div>
            <div class="dna-backbone right"></div>
          </div>
          <p>Double helix with base pairs</p>
        </div>
        <div class="grid-item" data-scene="heart">
          <h3>Human Heart</h3>
          <div class="mini" style="display:grid;place-items:center;">
            <div class="heart"></div>
          </div>
          <p>Anatomically accurate heart model</p>
        </div>
        <div class="grid-item" data-scene="atom">
          <h3>Atom Model</h3>
          <div class="mini">
            <div class="nucleus"></div>
            <div class="e-orbit" style="width:120px;height:120px;"><div class="e"></div></div>
            <div class="e-orbit" style="width:160px;height:90px;"><div class="e" style="animation-duration:4s;"></div></div>
            <div class="e-orbit" style="width:90px;height:160px;"><div class="e" style="animation-duration:2.2s;"></div></div>
          </div>
          <p>Nucleus with orbiting electrons</p>
        </div>
      </div>
    </div>
  </section>
  <!-- Player (3D + Gestures) -->
  <section id="player">
    <div id="container3d">
      <div id="viewport">
        <div class="holo-overlay"></div>
        <video id="video" autoplay playsinline muted></video>
        <div class="info">
          <h3>System Status</h3>
          <div class="status" id="st-camera">Camera: Initializing…</div>
          <div class="status" id="st-hand">Hand Tracking: Inactive</div>
          <div class="status" id="st-gesture">Gesture: None</div>
          <div class="status" id="st-fps">FPS: 0</div>
        </div>
        <div class="gesture-badge"><strong style="color:var(--cyan)">Active Gesture</strong>: <span id="badge-gesture">(none)</span></div>
        <button class="btn back" id="backToExplorer">← Explorer</button>
        
        <!-- Navigation Dot -->
        <div class="nav-dot" id="navDot"></div>
      </div>
    </div>
    
    <!-- Side Panel (Initially Hidden) -->
    <aside id="panel">
      <h3 style="text-align:center;color:var(--cyan);margin-bottom:12px;">Holographic Controls</h3>
      <div class="group">
        <h4>Scene</h4>
        <button class="pill" id="btn-solar">Solar System</button>
        <button class="pill" id="btn-dna">DNA Molecule</button>
        <button class="pill" id="btn-heart">Human Heart</button>
        <button class="pill" id="btn-atom">Atom Model</button>
      </div>
      <div class="group">
        <h4>Interaction Modes</h4>
        <button class="pill" data-mode="rotate">Rotate</button>
        <button class="pill" data-mode="scale">Scale</button>
        <button class="pill" data-mode="translate">Move</button>
      </div>
      <div class="group">
        <h4>Visualization</h4>
        <label>Animation Speed</label>
        <input id="speed" type="range" class="slider" min="0" max="2" step="0.1" value="1" />
        <div style="margin-top:8px">
          <button class="pill" id="toggle-anim">Pause Animation</button>
          <button class="pill alt" id="reset-view">Reset View</button>
        </div>
      </div>
      <div class="group">
        <h4>Settings</h4>
        <label>Gesture Sensitivity</label>
        <input id="sense" type="range" class="slider" min="0.5" max="2" step="0.1" value="1" />
        <div style="margin-top:8px">
          <button class="pill" id="calibrate">Calibrate</button>
          <button class="pill" id="fullscreen">Fullscreen</button>
        </div>
      </div>
      <div class="group" style="font-size:12px;color:#cbd5e1">
        <h4>Gestures Guide</h4>
        • Open Palm: rotate • Pinch: scale • Point: move • Fist: stop • Peace: reset
      </div>
      <div class="group">
        <h4>Lesson Mode</h4>
        <button class="pill" id="lesson-play">Play</button>
        <button class="pill" id="lesson-pause">Pause</button>
        <button class="pill" id="lesson-prev">◀ Prev</button>
        <button class="pill" id="lesson-next">Next ▶</button>
      </div>
      <div class="group">
        <h4>Annotations</h4>
        <button class="pill" id="toggle-annotate">Add labels</button>
        <button class="pill" id="clear-annotations">Clear</button>
      </div>
      <div class="group">
        <h4>Utilities</h4>
        <button class="pill" id="snapshot">Save PNG</button>
        <button class="pill" id="voice">🎤 Voice</button>
      </div>
      <div class="group">
        <h4>Collaboration</h4>
        <button class="pill" id="presenter-toggle">Become Presenter</button>
        <div style="margin-top:6px;font-size:12px">
          Latency: <span id="latency-badge">—</span> · Users: <span id="user-count">1</span> · Role: <span id="role-label">Follower</span>
        </div>
      </div>
    </aside>
    
    <div id="loading" class="loading"><div class="spinner"></div></div>
  </section>
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <!-- Socket.IO (for Presenter/Followers, annotations sync, latency) -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // ======= Simple router between sections
    const elLanding = document.getElementById('landing');
    const elExplorer = document.getElementById('explorer');
    const elPlayer = document.getElementById('player');
    const goExplorer = document.getElementById('goExplorer');
    const backToLanding = document.getElementById('backToLanding');
    const backToExplorer = document.getElementById('backToExplorer');
    const navDot = document.getElementById('navDot');
    const panel = document.getElementById('panel');
    // Toggle panel with navigation dot
    navDot.addEventListener('click', () => {
      panel.classList.toggle('active');
      navDot.classList.toggle('active');
      console.log('Nav dot clicked, panel active:', panel.classList.contains('active'));
    });
    function show(section) {
      elLanding.style.display = section==='landing' ? 'block' : 'none';
      elExplorer.style.display = section==='explorer' ? 'block' : 'none';
      elPlayer.style.display = section==='player' ? 'block' : 'none';
      document.body.style.overflow = (section==='explorer') ? 'auto' : 'hidden';
      
      // Hide panel when switching sections
      if (section !== 'player') {
        panel.classList.remove('active');
        navDot.classList.remove('active');
      }
      
      // Show nav dot only in player mode
      if (section === 'player') {
        navDot.style.display = 'flex';
      } else {
        navDot.style.display = 'none';
      }
    }
    
    goExplorer.onclick = () => show('explorer');
    backToLanding.onclick = () => show('landing');
    backToExplorer.onclick = () => show('explorer');
    // Build DNA mini preview bases
    (function buildMiniDNA(){
      const wrap = document.getElementById('miniDNA');
      const baseCount = 14; const height = 180;
      for (let i=0;i<baseCount;i++) {
        const base = document.createElement('div');
        base.className = 'dna-base';
        base.style.top = ((i/(baseCount-1))*height) + 'px';
        base.style.transform = 'rotate(' + (i%2? -28 : 28) + 'deg)';
        wrap.appendChild(base);
      }
    })();
    // Clicking a grid item launches the 3D player
    document.querySelectorAll('.grid-item').forEach(card => {
      card.addEventListener('click', () => {
        const sceneKey = card.getAttribute('data-scene');
        show('player');
        ensure3D().then(() => {
          loadScene(sceneKey);
        }).catch(err => {
          console.error(err);
          alert('Failed to initialize 3D/Camera. Please allow camera permission and reload.');
        });
      });
    });
    // ======= Three.js + Mediapipe Hands =======
    let scene, camera, renderer, currentModel;
    let videoEl, hands, handLandmarks = null;
    let interactionMode = 'rotate';
    let isAnimating = true;
    let animationSpeed = 1;
    let lastTS = 0, fps = 0;
    // NEW: scene key tracker for lessons/snapshots/sync
    let currentSceneKey = 'solar';
    const stCam = document.getElementById('st-camera');
    const stHand = document.getElementById('st-hand');
    const stGest = document.getElementById('st-gesture');
    const stFPS = document.getElementById('st-fps');
    const badgeGesture = document.getElementById('badge-gesture');
    async function ensure3D(){
      if (renderer) return; // already init
      videoEl = document.getElementById('video');
      await setupCamera();
      setupThree();
      setupHands();
      setupUI();
      setupExtrasUI(); // NEW: wire extra features
      setupSockets();  // NEW: realtime
      animate();
      hideLoading();
    }
    async function setupCamera(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        videoEl.srcObject = stream;
        await new Promise(res => videoEl.onloadedmetadata = () => res());
        stCam.textContent = 'Camera: Active';
      } catch (e) {
        stCam.textContent = 'Camera: Access Denied';
        throw e;
      }
    }
    function setupThree(){
      const vp = document.getElementById('viewport');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000510);
      camera = new THREE.PerspectiveCamera(75, vp.clientWidth / vp.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(vp.clientWidth, vp.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      vp.appendChild(renderer.domElement);
      const amb = new THREE.AmbientLight(0x404040, 0.6); scene.add(amb);
      const dir = new THREE.DirectionalLight(0x40e0ff, 0.8); dir.position.set(10,10,5); dir.castShadow = true; scene.add(dir);
      const pt = new THREE.PointLight(0x00ff80, 0.6, 100); pt.position.set(-10,-10,-5); scene.add(pt);
      window.addEventListener('resize', onResize);
      // Mouse fallback
      let down=false, mx=0, my=0;
      renderer.domElement.addEventListener('mousedown', e=>{ down=true; mx=e.clientX; my=e.clientY; });
      renderer.domElement.addEventListener('mouseup', ()=>down=false);
      renderer.domElement.addEventListener('mousemove', e=>{
        if (down && currentModel) {
          const dx = e.clientX - mx; const dy = e.clientY - my;
          currentModel.rotation.y += dx * 0.01;
          currentModel.rotation.x += dy * 0.01;
          mx = e.clientX; my = e.clientY;
          maybeEmitState(); // NEW: sync
        }
      });
    }
    function setupHands(){
      hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
      hands.onResults(onHandResults);
      const cam = new Camera(videoEl, { onFrame: async () => { await hands.send({ image: videoEl }); }, width: 640, height: 480 });
      cam.start();
    }
    function onHandResults(results){
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handLandmarks = results.multiHandLandmarks[0];
        stHand.textContent = 'Hand Tracking: Active';
        const g = recognizeGesture(handLandmarks);
        stGest.textContent = `Gesture: ${g.type}`;
        badgeGesture.textContent = mapGestureLabel(g.type);
        if (currentModel && g.type !== 'none') applyGestureToModel(g);
      } else {
        handLandmarks = null;
        stHand.textContent = 'Hand Tracking: No hands detected';
        stGest.textContent = 'Gesture: None';
        badgeGesture.textContent = '(none)';
      }
    }
    function recognizeGesture(lm){
      if (!lm || lm.length < 21) return { type:'none', confidence:0, position:{x:0,y:0,z:0} };
      const fingers = [];
      // thumb: compare x (assumes mirrored video)
      fingers.push(lm[4].x > lm[3].x);
      for (let i=1;i<=4;i++) fingers.push(lm[4 + i*4].y < lm[3 + i*4].y);
      const openCount = fingers.filter(Boolean).length;
      const idx = lm[8]; const th = lm[4];
      const pinchDist = Math.hypot(idx.x - th.x, idx.y - th.y);
      let type = 'none', conf = 0.7;
      if (pinchDist < 0.05) { type='pinch'; conf=0.9; }
      else if (openCount === 5) { type='open_palm'; conf=0.8; }
      else if (openCount === 1 && fingers[1]) { type='point'; conf=0.8; }
      else if (openCount === 0) { type='fist'; conf=0.8; }
      else if (openCount === 2 && fingers[1] && fingers[2]) { type='peace'; conf=0.8; }
      return { type, confidence: conf, position: { x: idx.x, y: idx.y, z: idx.z } };
    }
    function mapGestureLabel(t){
      return ({
        open_palm: '✋ Rotate',
        pinch: '👌 Scale',
        point: '👉 Move',
        fist: '✊ Pause',
        peace: '✌ Reset',
        none: '(none)'
      })[t] || '(none)';
    }
    function applyGestureToModel(g){
      if (!currentModel) return;
      const sensitivity = parseFloat(document.getElementById('sense').value);
      const f = sensitivity * 0.02;
      switch (g.type) {
        case 'open_palm':
          if (interactionMode==='rotate') {
            currentModel.rotation.y += (g.position.x - 0.5) * f;
            currentModel.rotation.x += (0.5 - g.position.y) * f;
            maybeEmitState(); // NEW
          }
          break;
        case 'pinch':
          if (interactionMode==='scale') {
            const s = Math.max(0.1, Math.min(3, g.position.y * 2));
            currentModel.scale.setScalar(s);
            maybeEmitState(); // NEW
          }
          break;
        case 'point':
          if (interactionMode==='translate') {
            currentModel.position.x = (g.position.x - 0.5) * 10;
            currentModel.position.y = (0.5 - g.position.y) * 10;
            maybeEmitState(); // NEW
          }
          break;
        case 'peace':
          resetView();
          maybeEmitState(); // NEW
          break;
        case 'fist':
          // no-op
          break;
      }
    }
    // ======= Scene loaders =======
    function clearScene(){
      // remove everything except lights will be re-added
      while (scene.children.length) { 
        const c = scene.children.pop(); 
        if (c.geometry) c.geometry.dispose(); 
        if (c.material) { 
          Array.isArray(c.material) ? c.material.forEach(m=>m.dispose()) : c.material.dispose(); 
        } 
      }
      const amb = new THREE.AmbientLight(0x404040, 0.6); scene.add(amb);
      const dir = new THREE.DirectionalLight(0x40e0ff, 0.8); dir.position.set(10,10,5); dir.castShadow = true; scene.add(dir);
      const pt = new THREE.PointLight(0x00ff80, 0.6, 100); pt.position.set(-10,-10,-5); scene.add(pt);
    }
    function addGlow(){
      if (!currentModel) return;
      const geom = new THREE.SphereGeometry(3, 32, 32);
      const mat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `uniform float time; varying vec2 vUv; void main(){ vec2 c=vec2(.5); float d=distance(vUv,c); float a = sin(time + d*10.0)*0.1 + 0.1; gl_FragColor = vec4(0.25, 0.88, 1.0, a*(1.0-d)); }`,
        transparent: true, side: THREE.BackSide
      });
      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      currentModel.userData.glow = mat;
    }
    function loadSolar(){
      clearScene();
      const root = new THREE.Group();
      
      // Create realistic Sun with corona effect
      const sunGeom = new THREE.SphereGeometry(0.8, 64, 64);
      const sunMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          sunColor: { value: new THREE.Color(0xffaa00) }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 sunColor;
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            float noise = sin(vUv.x * 20.0 + time * 2.0) * cos(vUv.y * 20.0 + time * 1.5) * 0.1;
            vec3 color = sunColor + noise;
            float fresnel = 1.0 - dot(vNormal, vec3(0,0,1));
            color += fresnel * vec3(1.0, 0.6, 0.2);
            gl_FragColor = vec4(color, 1.0);
          }
        `
      });
      const sun = new THREE.Mesh(sunGeom, sunMat);
      root.add(sun);
      sun.userData.type = 'sun';
      // Add corona glow
      const coronaGeom = new THREE.SphereGeometry(1.2, 32, 32);
      const coronaMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            float fresnel = 1.0 - dot(vNormal, vec3(0,0,1));
            float alpha = fresnel * 0.3 * (sin(time * 1.5) * 0.5 + 0.5);
            gl_FragColor = vec4(1.0, 0.7, 0.2, alpha);
          }
        `,
        transparent: true,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending
      });
      const corona = new THREE.Mesh(coronaGeom, coronaMat);
      root.add(corona);
      corona.userData.type = 'corona';
      // Realistic planet data with proper colors and sizes
      const planets = [
        { name:'Mercury', size:0.08, dist:2.0, color:0x8C7853, tilt:0.034, moons:[] },
        { name:'Venus', size:0.12, dist:2.7, color:0xFFC649, tilt:177.4, moons:[] },
        { name:'Earth', size:0.13, dist:3.5, color:0x6B93D6, tilt:23.4, moons:[{name:'Moon', size:0.035, dist:0.25}] },
        { name:'Mars', size:0.07, dist:4.3, color:0xCD5C5C, tilt:25.2, moons:[{name:'Phobos', size:0.01, dist:0.15}] },
        { name:'Jupiter', size:0.45, dist:6.0, color:0xD8CA9D, tilt:3.1, moons:[
          {name:'Io', size:0.04, dist:0.6}, {name:'Europa', size:0.032, dist:0.75}, 
          {name:'Ganymede', size:0.055, dist:0.9}, {name:'Callisto', size:0.05, dist:1.1}
        ]},
        { name:'Saturn', size:0.38, dist:7.8, color:0xFAD5A5, tilt:26.7, hasRings:true, moons:[
          {name:'Titan', size:0.055, dist:0.85}, {name:'Enceladus', size:0.025, dist:0.65}
        ]},
        { name:'Uranus', size:0.17, dist:9.5, color:0x4FD0E7, tilt:97.8, moons:[{name:'Miranda', size:0.02, dist:0.4}] },
        { name:'Neptune', size:0.16, dist:11.0, color:0x4B70DD, tilt:28.3, moons:[{name:'Triton', size:0.028, dist:0.5}] }
      ];
      planets.forEach((p, i) => {
        const planetGroup = new THREE.Group();
        
        // Create planet with realistic texture-like shader
        const planetGeom = new THREE.SphereGeometry(p.size, 32, 32);
        const planetMat = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            planetColor: { value: new THREE.Color(p.color) }
          },
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
              vUv = uv;
              vNormal = normalize(normalMatrix * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 planetColor;
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
              float noise = sin(vUv.x * 15.0) * cos(vUv.y * 10.0) * 0.1;
              vec3 color = planetColor * (0.9 + noise);
              float lighting = dot(vNormal, normalize(vec3(1,1,1))) * 0.5 + 0.5;
              gl_FragColor = vec4(color * lighting, 1.0);
            }
          `
        });
        
        const planet = new THREE.Mesh(planetGeom, planetMat);
        planet.position.x = p.dist;
        planet.rotation.z = (p.tilt * Math.PI) / 180; // Apply axial tilt
        planetGroup.add(planet);
        
        // Add Saturn's rings
        if (p.hasRings) {
          const ringGeom = new THREE.RingGeometry(p.size * 1.2, p.size * 2.2, 64);
          const ringMat = new THREE.MeshBasicMaterial({
            color: 0xD4AF37,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
          });
          const rings = new THREE.Mesh(ringGeom, ringMat);
          rings.rotation.x = Math.PI / 2;
          planet.add(rings);
        }
        
        // Add moons
        p.moons.forEach((moon, mi) => {
          const moonGroup = new THREE.Group();
          const moonGeom = new THREE.SphereGeometry(moon.size, 16, 16);
          const moonMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
          const moonMesh = new THREE.Mesh(moonGeom, moonMat);
          moonMesh.position.x = moon.dist;
          moonGroup.add(moonMesh);
          planet.add(moonGroup);
          
          moonMesh.userData = { 
            orbitSpeed: 0.05 + Math.random() * 0.03, 
            group: moonGroup,
            type: 'moon'
          };
        });
        // Create subtle orbital path
        const orbitGeom = new THREE.RingGeometry(p.dist - 0.02, p.dist + 0.02, 128);
        const orbitMat = new THREE.MeshBasicMaterial({
          color: 0x40e0ff,
          transparent: true,
          opacity: 0.15,
          side: THREE.DoubleSide
        });
        const orbitRing = new THREE.Mesh(orbitGeom, orbitMat);
        orbitRing.rotation.x = -Math.PI / 2;
        root.add(orbitRing);
        root.add(planetGroup);
        
        planet.userData = {
          orbitSpeed: 0.008 / (i * 0.5 + 1), // Realistic orbital periods
          rotationSpeed: 0.02 + Math.random() * 0.01,
          group: planetGroup,
          planetMaterial: planetMat,
          type: 'planet'
        };
      });
      // Add asteroid belt between Mars and Jupiter
      const asteroidCount = 200;
      for (let i = 0; i < asteroidCount; i++) {
        const angle = (i / asteroidCount) * Math.PI * 2;
        const distance = 4.8 + Math.random() * 0.8; // Between Mars and Jupiter
        const asteroidSize = 0.005 + Math.random() * 0.015;
        
        const asteroidGeom = new THREE.SphereGeometry(asteroidSize, 6, 6);
        const asteroidMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
        const asteroid = new THREE.Mesh(asteroidGeom, asteroidMat);
        
        asteroid.position.x = Math.cos(angle) * distance;
        asteroid.position.z = Math.sin(angle) * distance;
        asteroid.position.y = (Math.random() - 0.5) * 0.2;
        
        root.add(asteroid);
        asteroid.userData = {
          orbitSpeed: 0.006 + Math.random() * 0.002,
          rotationSpeed: Math.random() * 0.05,
          angle: angle,
          distance: distance,
          type: 'asteroid'
        };
      }
      // Add distant stars for galaxy effect
      const starCount = 1000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const radius = 20 + Math.random() * 30;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);
        
        const color = new THREE.Color();
        color.setHSL(Math.random() * 0.2 + 0.5, 0.8, 0.8 + Math.random() * 0.2);
        starColors[i3] = color.r;
        starColors[i3 + 1] = color.g;
        starColors[i3 + 2] = color.b;
      }
      
      const starGeom = new THREE.BufferGeometry();
      starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeom.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      
      const starMat = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
      });
      
      const stars = new THREE.Points(starGeom, starMat);
      root.add(stars);
      stars.userData.type = 'stars';
      scene.add(root);
      currentModel = root;
      addGlow();
    }
    function loadDNA(){
      clearScene();
      const root = new THREE.Group();
      const H=4, R=1, T=3, PPT=20;
      for (let turn=0; turn<T; turn++){
        for (let k=0; k<PPT; k++){
          const t=(turn*PPT+k)/(T*PPT); const y=(t-.5)*H; const ang=t*T*Math.PI*2;
          const x1=Math.cos(ang)*R, z1=Math.sin(ang)*R;
          const b1 = new THREE.Mesh(new THREE.SphereGeometry(.1,8,8), new THREE.MeshLambertMaterial({ color: Math.random()>.5?0xff6b6b:0x4ecdc4 }));
          b1.position.set(x1,y,z1); root.add(b1);
          const x2=Math.cos(ang+Math.PI)*R, z2=Math.sin(ang+Math.PI)*R;
          const b2 = new THREE.Mesh(new THREE.SphereGeometry(.1,8,8), new THREE.MeshLambertMaterial({ color: Math.random()>.5?0xffe66d:0x95e1d3 }));
          b2.position.set(x2,y,z2); root.add(b2);
          if (k%3===0){ const conn = new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,R*2), new THREE.MeshLambertMaterial({ color:0x40e0ff, transparent:true, opacity:.6 })); conn.position.set(0,y,0); conn.rotation.z = -ang; root.add(conn); }
        }
      }
      scene.add(root); currentModel = root; addGlow();
    }
    function loadHeart(){
      clearScene();
      const root = new THREE.Group();
      
      // Heart material with realistic appearance
      const heartMaterial = new THREE.MeshPhongMaterial({
        color: 0xd63031,
        shininess: 30,
        transparent: true,
        opacity: 0.9,
        specular: 0xff6b6b
      });
      
      // Vessel material
      const vesselMaterial = new THREE.MeshPhongMaterial({
        color: 0xe74c3c,
        shininess: 20,
        transparent: true,
        opacity: 0.8
      });
      
      // Create realistic heart shape using parametric equations
      class HeartGeometry extends THREE.BufferGeometry {
        constructor() {
          super();
          
          const points = [];
          const segments = 64;
          const rings = 32;
          
          // Generate heart surface points using parametric equations
          for (let i = 0; i <= segments; i++) {
            const u = (i / segments) * Math.PI * 2;
            for (let j = 0; j <= rings; j++) {
              const v = (j / rings) * Math.PI;
              
              // Heart parametric equations
              const x = 0.5 * (16 * Math.pow(Math.sin(u), 3));
              const y = -0.5 * (13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u));
              const z = 0.5 * Math.sin(v) * 0.5;
              
              // Scale and position
              const scale = 0.08;
              points.push(
                x * scale,
                y * scale,
                z * scale
              );
            }
          }
          
          // Create indices for triangles
          const indices = [];
          for (let i = 0; i < segments; i++) {
            for (let j = 0; j < rings; j++) {
              const a = i * (rings + 1) + j;
              const b = a + rings + 1;
              const c = a + 1;
              const d = b + 1;
              
              indices.push(a, b, c);
              indices.push(b, d, c);
            }
          }
          
          // Set geometry attributes
          this.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
          this.setIndex(indices);
          this.computeVertexNormals();
        }
      }
      
      // Create main heart body
      const heartGeometry = new HeartGeometry();
      const heart = new THREE.Mesh(heartGeometry, heartMaterial);
      heart.position.set(0, 0, 0);
      heart.scale.set(1.5, 1.5, 1.5);
      root.add(heart);
      
      // Create left atrium
      const leftAtriumGeometry = new THREE.SphereGeometry(0.4, 32, 32);
      const leftAtrium = new THREE.Mesh(leftAtriumGeometry, heartMaterial);
      leftAtrium.position.set(-0.3, 0.4, 0);
      leftAtrium.scale.set(1, 0.8, 0.8);
      root.add(leftAtrium);
      
      // Create right atrium
      const rightAtrium = new THREE.Mesh(leftAtriumGeometry, heartMaterial);
      rightAtrium.position.set(0.3, 0.4, 0);
      rightAtrium.scale.set(1, 0.8, 0.8);
      root.add(rightAtrium);
      
      // Create left ventricle
      const leftVentricleGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const leftVentricle = new THREE.Mesh(leftVentricleGeometry, heartMaterial);
      leftVentricle.position.set(-0.3, -0.2, 0);
      leftVentricle.scale.set(0.9, 1.2, 0.9);
      root.add(leftVentricle);
      
      // Create right ventricle
      const rightVentricle = new THREE.Mesh(leftVentricleGeometry, heartMaterial);
      rightVentricle.position.set(0.3, -0.2, 0);
      rightVentricle.scale.set(0.9, 1.2, 0.9);
      root.add(rightVentricle);
      
      // Create aorta
      const aortaCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-0.3, 0.4, 0),
        new THREE.Vector3(-0.5, 0.7, 0),
        new THREE.Vector3(-0.7, 1.0, 0),
        new THREE.Vector3(-0.9, 1.3, 0)
      ]);
      
      const aortaGeometry = new THREE.TubeGeometry(aortaCurve, 20, 0.12, 8, false);
      const aorta = new THREE.Mesh(aortaGeometry, vesselMaterial);
      root.add(aorta);
      
      // Create pulmonary artery
      const pulmonaryCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0.3, 0.4, 0),
        new THREE.Vector3(0.5, 0.7, 0),
        new THREE.Vector3(0.7, 1.0, 0),
        new THREE.Vector3(0.9, 1.3, 0)
      ]);
      
      const pulmonaryGeometry = new THREE.TubeGeometry(pulmonaryCurve, 20, 0.1, 8, false);
      const pulmonary = new THREE.Mesh(pulmonaryGeometry, vesselMaterial);
      root.add(pulmonary);
      
      // Create vena cava
      const venaCavaCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0.3, 0.4, 0),
        new THREE.Vector3(0.3, 0.1, 0),
        new THREE.Vector3(0.3, -0.3, 0),
        new THREE.Vector3(0.3, -0.7, 0)
      ]);
      
      const venaCavaGeometry = new THREE.TubeGeometry(venaCavaCurve, 20, 0.08, 8, false);
      const venaCava = new THREE.Mesh(venaCavaGeometry, vesselMaterial);
      root.add(venaCava);
      
      // Create pulmonary veins
      const pulmonaryVeinCurve1 = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-0.3, 0.4, 0),
        new THREE.Vector3(-0.5, 0.5, 0),
        new THREE.Vector3(-0.7, 0.6, 0)
      ]);
      
      const pulmonaryVeinCurve2 = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-0.3, 0.4, 0),
        new THREE.Vector3(-0.1, 0.5, 0),
        new THREE.Vector3(0.1, 0.6, 0)
      ]);
      
      const pulmonaryVeinGeometry = new THREE.TubeGeometry(pulmonaryVeinCurve1, 20, 0.06, 8, false);
      const pulmonaryVein1 = new THREE.Mesh(pulmonaryVeinGeometry, vesselMaterial);
      root.add(pulmonaryVein1);
      
      const pulmonaryVein2 = new THREE.Mesh(
        new THREE.TubeGeometry(pulmonaryVeinCurve2, 20, 0.06, 8, false),
        vesselMaterial
      );
      root.add(pulmonaryVein2);
      
      // Add coronary arteries
      const coronaryCurve1 = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0.2, 0.1, 0.2),
        new THREE.Vector3(0.4, 0.2, 0.3),
        new THREE.Vector3(0.6, 0.3, 0.2)
      ]);
      
      const coronaryCurve2 = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(-0.2, 0.1, 0.2),
        new THREE.Vector3(-0.4, 0.2, 0.3),
        new THREE.Vector3(-0.6, 0.3, 0.2)
      ]);
      
      const coronaryGeometry = new THREE.TubeGeometry(coronaryCurve1, 20, 0.04, 8, false);
      const coronary1 = new THREE.Mesh(coronaryGeometry, vesselMaterial);
      root.add(coronary1);
      
      const coronary2 = new THREE.Mesh(
        new THREE.TubeGeometry(coronaryCurve2, 20, 0.04, 8, false),
        vesselMaterial
      );
      root.add(coronary2);
      
      // Add septum
      const septumGeometry = new THREE.BoxGeometry(0.08, 0.8, 0.6);
      const septum = new THREE.Mesh(septumGeometry, heartMaterial);
      septum.position.set(0, 0, 0);
      root.add(septum);
      
      // Add valves
      const valveGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
      const tricuspidValve = new THREE.Mesh(valveGeometry, vesselMaterial);
      tricuspidValve.position.set(0.2, 0, 0);
      tricuspidValve.rotation.x = Math.PI / 2;
      root.add(tricuspidValve);
      
      const mitralValve = new THREE.Mesh(valveGeometry, vesselMaterial);
      mitralValve.position.set(-0.2, 0, 0);
      mitralValve.rotation.x = Math.PI / 2;
      root.add(mitralValve);
      
      // Store reference to heart for animation
      root.userData.heart = heart;
      root.userData.leftAtrium = leftAtrium;
      root.userData.rightAtrium = rightAtrium;
      root.userData.leftVentricle = leftVentricle;
      root.userData.rightVentricle = rightVentricle;
      root.userData.aorta = aorta;
      root.userData.pulmonary = pulmonary;
      root.userData.venaCava = venaCava;
      root.userData.pulmonaryVein1 = pulmonaryVein1;
      root.userData.pulmonaryVein2 = pulmonaryVein2;
      root.userData.coronary1 = coronary1;
      root.userData.coronary2 = coronary2;
      root.userData.septum = septum;
      root.userData.tricuspidValve = tricuspidValve;
      root.userData.mitralValve = mitralValve;
      
      scene.add(root);
      currentModel = root;
      addGlow();
    }
    function loadAtom(){
      clearScene();
      const root = new THREE.Group();
      const nucleus = new THREE.Mesh(new THREE.SphereGeometry(.3,16,16), new THREE.MeshLambertMaterial({ color:0xffaa00, emissive:0xff6600, emissiveIntensity:.2 }));
      root.add(nucleus);
      const orbits=[]; const count=3;
      for (let i=0;i<count;i++){
        const grp = new THREE.Group(); const r=(i+1)*0.8;
        const ring = new THREE.Mesh(new THREE.RingGeometry(r-0.02, r+0.02, 64), new THREE.MeshBasicMaterial({ color:0x40e0ff, transparent:true, opacity:.3, side: THREE.DoubleSide }));
        ring.rotation.x = Math.random()*Math.PI; ring.rotation.y = Math.random()*Math.PI; grp.add(ring);
        const eCount = i+2;
        for (let j=0;j<eCount;j++){
          const electron = new THREE.Mesh(new THREE.SphereGeometry(.08,8,8), new THREE.MeshBasicMaterial({ color:0x00ff88 }));
          electron.position.x = r; const eOrbit = new THREE.Group(); eOrbit.add(electron); eOrbit.rotation.y = (j/eCount)*Math.PI*2; grp.add(eOrbit);
          electron.userData = { orbitSpeed: (0.02*(i+1)) + Math.random()*0.01, orbit: eOrbit };
        }
        root.add(grp); orbits.push(grp);
      }
      scene.add(root); currentModel = root; addGlow();
    }
    function loadScene(key){
      // NEW: remember key for lessons/sync/snapshot
      currentSceneKey = key || currentSceneKey;
      const sceneLoaders = {
        solar: loadSolar,
        dna: loadDNA,
        heart: loadHeart,
        atom: loadAtom
      };
      (sceneLoaders[currentSceneKey] || loadSolar)();
      maybeEmitState(); // NEW: broadcast scene switch
    }
    // ======= UI wiring in Player =======
    function setupUI(){
      document.getElementById('btn-solar').onclick = () => loadScene('solar');
      document.getElementById('btn-dna').onclick = () => loadScene('dna');
      document.getElementById('btn-heart').onclick = () => loadScene('heart');
      document.getElementById('btn-atom').onclick = () => loadScene('atom');
      document.querySelectorAll('[data-mode]').forEach(b=> b.onclick = ()=> setMode(b.getAttribute('data-mode')));
      document.getElementById('toggle-anim').onclick = toggleAnim;
      document.getElementById('reset-view').onclick = () => { resetView(); maybeEmitState(); };
      document.getElementById('fullscreen').onclick = toggleFullscreen;
      document.getElementById('calibrate').onclick = calibrate;
      document.getElementById('speed').oninput = (e)=> animationSpeed = parseFloat(e.target.value);
      // keyboard
      document.addEventListener('keydown', (e)=>{
        switch(e.key){
          case '1': loadScene('solar'); break;
          case '2': loadScene('dna'); break;
          case '3': loadScene('heart'); break;
          case '4': loadScene('atom'); break;
          case 'r': setMode('rotate'); break; case 's': setMode('scale'); break; case 'm': setMode('translate'); break;
          case ' ': e.preventDefault(); toggleAnim(); break; case 'Escape': resetView(); maybeEmitState(); break; case 'f': toggleFullscreen(); break;
        }
      });
    }
    function setMode(m){
      interactionMode = m;
      // Visual feedback could be added here
    }
    function toggleAnim(){
      isAnimating = !isAnimating;
      const btn = document.getElementById('toggle-anim');
      btn.textContent = isAnimating ? 'Pause Animation' : 'Resume Animation';
    }
    function resetView(){ if (!currentModel) return; currentModel.rotation.set(0,0,0); currentModel.position.set(0,0,0); currentModel.scale.set(1,1,1); camera.position.set(0,0,5); camera.lookAt(0,0,0); }
    function toggleFullscreen(){ if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }
    function calibrate(){ alert('Calibration: show open palm, then pinch, point, fist, and peace sign. Done!'); }
    function onResize(){
      const vp = document.getElementById('viewport');
      camera.aspect = vp.clientWidth / vp.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(vp.clientWidth, vp.clientHeight);
    }
    function hideLoading(){ const l = document.getElementById('loading'); if (l) l.style.display = 'none'; }
    // ======= Animation Loop =======
    function animate(ts=0){
      requestAnimationFrame(animate);
      if (ts - lastTS >= 250) {
        const frameMs = ts - lastTS; fps = frameMs ? Math.round(1000 / frameMs) : fps; stFPS.textContent = `FPS: ${fps}`; lastTS = ts;
      }
      if (isAnimating && currentModel){
        currentModel.rotation.y += 0.005 * animationSpeed;
        
        if (currentModel.children) {
          currentModel.children.forEach(ch => {
            // Handle solar system specific animations
            if (ch.userData && ch.userData.type === 'sun') {
              ch.material.uniforms.time.value = ts * 0.001;
              ch.rotation.y += 0.01 * animationSpeed;
            } else if (ch.userData && ch.userData.type === 'corona') {
              ch.material.uniforms.time.value = ts * 0.001;
              ch.rotation.y -= 0.005 * animationSpeed;
            } else if (ch.userData && ch.userData.type === 'planet' && ch.userData.group) {
              // Orbital motion
              ch.userData.group.rotation.y += ch.userData.orbitSpeed * animationSpeed;
              // Planet rotation
              ch.rotation.y += ch.userData.rotationSpeed * animationSpeed;
              // Update planet shader time
              if (ch.userData.planetMaterial) {
                ch.userData.planetMaterial.uniforms.time.value = ts * 0.001;
              }
            } else if (ch.userData && ch.userData.type === 'asteroid') {
              // Asteroid orbital motion and rotation
              ch.userData.angle += ch.userData.orbitSpeed * animationSpeed;
              ch.position.x = Math.cos(ch.userData.angle) * ch.userData.distance;
              ch.position.z = Math.sin(ch.userData.angle) * ch.userData.distance;
              ch.rotation.x += ch.userData.rotationSpeed * animationSpeed;
              ch.rotation.y += ch.userData.rotationSpeed * animationSpeed * 0.7;
            } else if (ch.userData && ch.userData.type === 'stars') {
              ch.rotation.y += 0.0002 * animationSpeed; // Very slow galaxy rotation
            }
            
            // Handle nested objects (moons, etc.)
            if (ch.children) {
              ch.children.forEach(subCh => {
                if (subCh.children) {
                  subCh.children.forEach(moon => {
                    if (moon.userData && moon.userData.type === 'moon') {
                      moon.userData.group.rotation.y += moon.userData.orbitSpeed * animationSpeed;
                    }
                  });
                }
              });
            }
            
            // Legacy animation support for other models
            if (ch.userData && ch.userData.orbitSpeed && ch.userData.group && !ch.userData.type) {
              ch.userData.group.rotation.y += ch.userData.orbitSpeed * animationSpeed;
              if (ch.children && ch.children[0]) ch.children[0].rotation.y += (ch.userData.rotationSpeed||0) * animationSpeed;
            } else if (ch.children && !ch.userData.type) {
              ch.children.forEach(sub => {
                if (sub.userData && sub.userData.orbit) sub.userData.orbit.rotation.y += sub.userData.orbitSpeed * animationSpeed;
              });
            }
          });
        }
        
        // Heart beating animation
        if (currentModel.userData && currentModel.userData.heart) {
          const beatScale = 0.05 * Math.sin(ts * 0.005 * animationSpeed);
          
          // Animate main heart
          if (currentModel.userData.heart) {
            currentModel.userData.heart.scale.set(
              1.5 + beatScale,
              1.5 + beatScale,
              1.5 + beatScale
            );
          }
          
          // Animate atria
          if (currentModel.userData.leftAtrium) {
            currentModel.userData.leftAtrium.scale.set(
              1 + beatScale * 0.8,
              0.8 + beatScale * 0.8,
              0.8 + beatScale * 0.8
            );
          }
          
          if (currentModel.userData.rightAtrium) {
            currentModel.userData.rightAtrium.scale.set(
              1 + beatScale * 0.8,
              0.8 + beatScale * 0.8,
              0.8 + beatScale * 0.8
            );
          }
          
          // Animate ventricles
          if (currentModel.userData.leftVentricle) {
            currentModel.userData.leftVentricle.scale.set(
              0.9 + beatScale * 0.9,
              1.2 + beatScale * 0.9,
              0.9 + beatScale * 0.9
            );
          }
          
          if (currentModel.userData.rightVentricle) {
            currentModel.userData.rightVentricle.scale.set(
              0.9 + beatScale * 0.9,
              1.2 + beatScale * 0.9,
              0.9 + beatScale * 0.9
            );
          }
          
          // Animate vessels
          if (currentModel.userData.aorta) {
            currentModel.userData.aorta.scale.set(
              1 + beatScale * 0.7,
              1 + beatScale * 0.7,
              1 + beatScale * 0.7
            );
          }
          
          if (currentModel.userData.pulmonary) {
            currentModel.userData.pulmonary.scale.set(
              1 + beatScale * 0.7,
              1 + beatScale * 0.7,
              1 + beatScale * 0.7
            );
          }
          
          if (currentModel.userData.venaCava) {
            currentModel.userData.venaCava.scale.set(
              1 + beatScale * 0.5,
              1 + beatScale * 0.5,
              1 + beatScale * 0.5
            );
          }
          
          if (currentModel.userData.pulmonaryVein1) {
            currentModel.userData.pulmonaryVein1.scale.set(
              1 + beatScale * 0.5,
              1 + beatScale * 0.5,
              1 + beatScale * 0.5
            );
          }
          
          if (currentModel.userData.pulmonaryVein2) {
            currentModel.userData.pulmonaryVein2.scale.set(
              1 + beatScale * 0.5,
              1 + beatScale * 0.5,
              1 + beatScale * 0.5
            );
          }
          
          if (currentModel.userData.coronary1) {
            currentModel.userData.coronary1.scale.set(
              1 + beatScale * 0.6,
              1 + beatScale * 0.6,
              1 + beatScale * 0.6
            );
          }
          
          if (currentModel.userData.coronary2) {
            currentModel.userData.coronary2.scale.set(
              1 + beatScale * 0.6,
              1 + beatScale * 0.6,
              1 + beatScale * 0.6
            );
          }
        }
        
        if (currentModel.userData && currentModel.userData.glow) currentModel.userData.glow.uniforms.time.value = ts * 0.001;
      }
      renderer && renderer.render(scene, camera);
    }
    /* ===========================
       EXTRA FEATURES
       =========================== */
    // Lesson Mode
    const LESSONS = {
      solar: [
        { dur: 1200, cam:{x:0,y:0,z:7}, look:{x:0,y:0,z:0} },
        { dur: 1200, cam:{x:2.5,y:0.6,z:3.5}, look:{x:2.5,y:0,z:0} },
        { dur: 1200, cam:{x:5.5,y:1.0,z:4.0}, look:{x:4.0,y:0,z:0} },
      ],
      dna: [
        { dur: 1200, cam:{x:0,y:0,z:6}, look:{x:0,y:0,z:0} },
        { dur: 1200, cam:{x:1.2,y:1.2,z:3.8}, look:{x:0,y:0.5,z:0} },
      ],
      heart: [
        { dur: 1200, cam:{x:0.5,y:0.6,z:4.6}, look:{x:0,y:0,z:0} },
        { dur: 1200, cam:{x:-0.5,y:1.2,z:3.8}, look:{x:0,y:0.5,z:0} },
      ],
      atom: [
        { dur: 1200, cam:{x:0,y:0,z:5.5}, look:{x:0,y:0,z:0} },
        { dur: 1200, cam:{x:1.6,y:0.8,z:3.0}, look:{x:0,y:0,z:0} },
      ]
    };
    let lessonPlaying = false;
    let lessonIdx = 0;
    let activeTween = null;
    function tweenCamera({cam, look, dur}) {
      const start = { cx: camera.position.x, cy: camera.position.y, cz: camera.position.z };
      const startLook = new THREE.Vector3();
      camera.getWorldDirection(startLook);
      const startTarget = new THREE.Vector3().copy(camera.position).add(startLook);
      const end = { cx: cam.x, cy: cam.y, cz: cam.z };
      const endTarget = new THREE.Vector3(look.x, look.y, look.z);
      const t0 = performance.now();
      const ease = t => t<.5 ? 2*t*t : -1+(4-2*t)*t;
      let cancelled = false;
      return {
        cancel(){ cancelled = true; },
        promise: new Promise(res=>{
          function step(now){
            if (cancelled) return;
            const k = Math.min(1, (now - t0)/dur);
            const e = ease(k);
            camera.position.set(
              start.cx + (end.cx - start.cx)*e,
              start.cy + (end.cy - start.cy)*e,
              start.cz + (end.cz - start.cz)*e
            );
            const target = new THREE.Vector3(
              startTarget.x + (endTarget.x - startTarget.x)*e,
              startTarget.y + (endTarget.y - startTarget.y)*e,
              startTarget.z + (endTarget.z - startTarget.z)*e
            );
            camera.lookAt(target);
            if (k<1) { requestAnimationFrame(step); }
            else { maybeEmitState(); res(); }
          }
          requestAnimationFrame(step);
        })
      };
    }
    function setupExtrasUI(){
      document.getElementById('lesson-play').onclick = async () => {
        lessonPlaying = true;
        const seq = LESSONS[currentSceneKey] || [];
        while (lessonPlaying && seq.length) {
          const step = seq[lessonIdx % seq.length];
          if (activeTween) activeTween.cancel();
          activeTween = tweenCamera(step);
          await activeTween.promise;
          lessonIdx++;
        }
      };
      document.getElementById('lesson-pause').onclick = () => {
        lessonPlaying = false;
        if (activeTween) activeTween.cancel();
      };
      document.getElementById('lesson-prev').onclick = () => {
        const seq = LESSONS[currentSceneKey] || [];
        lessonIdx = (lessonIdx - 1 + seq.length) % seq.length;
        if (seq[lessonIdx]) {
          if (activeTween) activeTween.cancel();
          activeTween = tweenCamera(seq[lessonIdx]);
        }
      };
      document.getElementById('lesson-next').onclick = () => {
        const seq = LESSONS[currentSceneKey] || [];
        lessonIdx = (lessonIdx + 1) % seq.length;
        if (seq[lessonIdx]) {
          if (activeTween) activeTween.cancel();
          activeTween = tweenCamera(seq[lessonIdx]);
        }
      };
      document.getElementById('toggle-annotate').onclick = () => {
        annotateMode = !annotateMode;
        alert(annotateMode ? 'Annotation mode: click a point on the model.' : 'Annotation mode off.');
      };
      document.getElementById('clear-annotations').onclick = () => {
        annotations.forEach(a => scene.remove(a.sprite));
        annotations.length = 0;
        if (window.socket) socket.emit('annotation:clear');
      };
      document.getElementById('snapshot').onclick = () => {
        const url = renderer.domElement.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url; a.download = `hologram-${currentSceneKey}.png`;
        document.body.appendChild(a); a.click(); a.remove();
      };
      document.getElementById('voice').onclick = toggleVoice;
    }
    // Annotations
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let annotateMode = false;
    const annotations = [];
    function makeLabelSprite(text){
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      const pad = 8, fs = 22; ctx.font = `${fs}px Arial`;
      const w = ctx.measureText(text).width + pad*2, h = fs + pad*2;
      c.width = w * 2; c.height = h * 2;
      const ctx2 = c.getContext('2d'); ctx2.scale(2,2);
      ctx2.font = `${fs}px Arial`;
      ctx2.fillStyle = 'rgba(0,20,40,0.85)'; ctx2.strokeStyle = '#40e0ff';
      ctx2.lineWidth = 2;
      if (ctx2.roundRect) ctx2.roundRect(1,1,w-2,h-2,8); else { ctx2.rect(1,1,w-2,h-2); }
      ctx2.fill(); ctx2.stroke();
      ctx2.fillStyle = '#fff'; ctx2.fillText(text, pad, pad + fs*0.78);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(w/100, h/100, 1);
      return spr;
    }
    document.addEventListener('click', (e) => {
      if (!annotateMode || !renderer || !currentModel || elPlayer.style.display !== 'block') return;
      const rect = renderer.domElement.getBoundingClientRect();
      if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) return;
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(currentModel, true);
      if (!hits.length) return;
      const p = hits[0].point.clone();
      const text = prompt('Label text:', 'Label');
      if (!text) return;
      const sprite = makeLabelSprite(text);
      sprite.position.copy(p);
      scene.add(sprite);
      const id = Math.random().toString(36).slice(2);
      annotations.push({ id, text, sprite, pos: p.clone() });
      if (window.socket) socket.emit('annotation:add', { id, text, pos: p });
    });
    // Voice commands
    let recog = null, listening = false;
    const commands = {
      'reset': () => { resetView(); maybeEmitState(); },
      'pause': () => toggleAnim(),
      'resume': () => toggleAnim(),
      'rotate mode': () => setMode('rotate'),
      'scale mode': () => setMode('scale'),
      'move mode': () => setMode('translate'),
      'switch to solar': () => loadScene('solar'),
      'switch to dna': () => loadScene('dna'),
      'switch to heart': () => loadScene('heart'),
      'switch to atom': () => loadScene('atom'),
    };
    function toggleVoice(){
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('Speech Recognition not supported in this browser.');
        return;
      }
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!recog) {
        recog = new SR(); recog.lang = 'en-US'; recog.interimResults = false; recog.continuous = true;
        recog.onresult = (e) => {
          const i = e.results.length - 1; const phrase = e.results[i][0].transcript.trim().toLowerCase();
          console.log('Voice:', phrase);
          for (const key in commands) if (phrase.includes(key)) { commands[key](); break; }
        };
        recog.onend = () => { if (listening) recog.start(); };
      }
      listening = !listening;
      if (listening) { recog.start(); alert('Voice ON: try "reset", "switch to DNA", "rotate mode"…'); }
      else { recog.stop(); alert('Voice OFF'); }
    }
    // Socket.io collaboration
    let socket = null;
    let isPresenter = false;
    const roleLabel = document.getElementById('role-label');
    const userCountLabel = document.getElementById('user-count');
    const latencyBadge = document.getElementById('latency-badge');
    function setupSockets(){
      try {
        socket = io('http://localhost:3000');
        window.socket = socket;
        socket.on('connect', () => console.log('Socket connected', socket.id));
        socket.on('presence', n => userCountLabel.textContent = n);
        socket.on('presenter:update', id => {
          isPresenter = (id && id === socket.id);
          roleLabel.textContent = isPresenter ? 'Presenter' : 'Follower';
        });
        socket.on('init', ({ state, presenterId }) => {
          isPresenter = (presenterId && presenterId === socket.id);
          roleLabel.textContent = isPresenter ? 'Presenter' : 'Follower';
          applyRemoteState(state);
        });
        socket.on('state', applyRemoteState);
        socket.on('annotation:add', ({id, text, pos}) => {
          const sprite = makeLabelSprite(text);
          sprite.position.set(pos.x, pos.y, pos.z);
          scene.add(sprite);
          annotations.push({ id, text, sprite, pos: new THREE.Vector3(pos.x,pos.y,pos.z) });
        });
        socket.on('annotation:clear', () => {
          annotations.forEach(a => scene.remove(a.sprite));
          annotations.length = 0;
        });
        setInterval(() => {
          if (!socket || socket.disconnected) { latencyBadge.textContent = '—'; return; }
          const t = performance.now();
          socket.emit('ping:client', t);
        }, 1500);
        socket.on('pong:server', (t) => {
          const rtt = performance.now() - t;
          updateLatency(rtt);
        });
        document.getElementById('presenter-toggle').onclick = () => {
          if (isPresenter) { socket.emit('presenter:release'); isPresenter = false; }
          else { socket.emit('presenter:claim'); }
        };
      } catch (e) {
        console.log('Socket.io not available (server not running)');
      }
    }
    function updateLatency(ms){
      latencyBadge.textContent = ms.toFixed(0) + ' ms';
      latencyBadge.style.color = ms < 80 ? '#7CFC00' : ms < 200 ? '#FFD700' : '#FF6347';
    }
    let lastEmit = 0;
    function presenterLocked(){ return true; }
    function maybeEmitState(){
      if (!socket) return;
      if (presenterLocked() && !isPresenter) return;
      const now = performance.now();
      if (now - lastEmit < 70) return;
      lastEmit = now;
      const s = captureState();
      socket.emit('state', s);
    }
    function captureState(){
      return {
        scene: currentSceneKey,
        transform: {
          position: [currentModel.position.x, currentModel.position.y, currentModel.position.z],
          rotation: [currentModel.rotation.x, currentModel.rotation.y, currentModel.rotation.z],
          scale: currentModel.scale.x
        },
        mode: interactionMode,
        ts: performance.now()
      };
    }
    function applyRemoteState(s){
      if (!currentModel) loadScene(s.scene);
      currentSceneKey = s.scene;
      const t = s.transform;
      if (currentModel && t) {
        currentModel.position.set(t.position[0], t.position[1], t.position[2]);
        currentModel.rotation.set(t.rotation[0], t.rotation[1], t.rotation[2]);
        currentModel.scale.setScalar(t.scale);
      }
      if (s.mode) interactionMode = s.mode;
    }
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      show('landing');
    });
  </script>
</body>
</html>